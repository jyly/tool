public class MainActivity extends AppCompatActivity {
    TextView gprint;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        double []a={-0.5724802288888888, -0.5554547955555557, -0.5139553, -0.4767121644444444, -0.4384049377777778, -0.39690544222222224, -0.36391866, -0.33518824111111106, -0.2979451, -0.2585737822222222, -0.23835607999999997, -0.24367652777777773, -0.22877927222222216, -0.2255870033333333, -0.24261243888888886, -0.22984336333333333, -0.22877927444444443, -0.21920246888888886, -0.2160101988888889, -0.2053693011111111, -0.17983115044444445, -0.17770297044444444, -0.16599798422222223, -0.140459832, -0.12237030833333332, -0.09044761977777777, -0.06490946755555556, -0.03405086755555555, -0.03511495755555555, -0.040435405999999986, -0.022345882222222217, -0.00851271733333333, 0.010640896222222224, 0.029794510333333333, 0.03192268955555556, 0.018089524000000003, 0.013833165111111111, 0.05958901844444443, 0.09470397622222222, 0.09470397622222222, 0.0989603351111111, 0.10321669377777776, 0.09576806533333333, 0.09044761722222222, 0.10108851355555556, 0.1149216791111111, 0.10747305244444445, 0.10640896466666666, 0.12343439866666667, 0.1213062188888889, 0.11704986022222222, 0.12024212977777779, 0.12449848811111111, 0.14897254844444446, 0.16174162511111112, 0.16067753622222222, 0.14365210066666664, 0.13726756288888886, 0.17238252155555556, 0.21068974911111113, 0.22771518355555553, 0.25218924666666664, 0.24367653111111112, 0.23303563333333333, 0.21707428855555555, 0.22771518522222223, 0.2149461096666667, 0.17344661333333336, 0.13194711711111115, 0.10108851711111111, 0.06597355799999999, 0.03937131688888889, 0.01383316577777778, -0.0031922683333333295, -0.03192268877777778, -0.061717198777777774, -0.06703764688888889, -0.07129400555555555, -0.07980672266666666, -0.07661445399999998, -0.07342218511111111, -0.08087081288888888, -0.06278128933333332, -0.03298678, 0.01489725333333334, 0.05001221, 0.06597355488888888, 0.09683215422222222, 0.13088302244444444, 0.14258800844444444, 0.161741622, 0.16706207000000003, 0.15003663633333336, 0.13513938188888888, 0.11704985899999999, 0.09151170677777777, 0.05426856899999999, 0.02021770077777777, 0.02660223922222222, 0.040435404555555554, 0.028730418888888883, -0.002128181888888893, 0.0010640869999999948, -0.004256361000000003, -0.001064091444444447, 0.01915361211111111, 0.035114957, 0.021281791111111108, 0.019153612222222213, 0.041499494111111104, 0.069165826, 0.03830722599999999, 0.03830722599999999, 0.05533266022222221, 0.044691764222222215, 0.010640895333333327, 0.0021281778888888854, -0.004256360555555555, -0.022345883888888893, -0.023409973555555557, -0.014897255777777778, -0.04043540711111111, -0.04469176566666667, -0.041499497, -0.07342218477777777, -0.040435405888888894, -0.030858598555555557, -0.023409971444444455, -0.023409971444444455, -0.011704985444444444, 0.01276907644444444, 0.009576807555555554, 0.00425635911111111, 0.047884033111111106, 0.017025434, -0.0021281796666666702, -0.012769075666666664, -0.013833165333333331, -0.008512716888888886, -0.004256358333333333, 0.0021281797777777814, 0.002128179777777778, 0.007448628000000001, 0.017025434555555555, 0.007448627777777777, -0.007448627777777779, -0.025538151444444445, -0.04788403477777778, -0.07767854411111111, -0.10215260633333333};
        Complex[] x=new Complex[10];
        x[0] = new Complex(0, 0);
        x[1] = new Complex(1, 0);
        x[2] = new Complex(0, 0);
        x[3] = new Complex(-1, 0);
        x[4] = new Complex(0, 0);
        x[5] = new Complex(1, 0);
        x[6] = new Complex(0, 0);
        x[7] = new Complex(-1, 0);
        x[8] = new Complex(0, 0);
        x[9] = new Complex(1, 0);
        x=fft(x);
        for (int i = 0; i < x.length; i++) {
            Log.e(">>>", "a"+i+"=" + x[i].a+"   b"+i+"=" + x[i].b);
        }
        int xlen=(int)(x.length/2);
        double[] fluency=new double[xlen];
        double[] fft=new double[xlen];
        for (int i = 0; i < xlen; i++) {
            fft[i]=Math.sqrt(x[i].a*x[i].a+x[i].b*x[i].b)/(double)(x.length);
            fluency[i]=i/(double)(x.length);
        }
        for (int i = 0; i < xlen; i++) {
            Log.e(">>>", "fft"+i+"=" + fft[i]+"   fluency"+i+"=" +  fluency[i]);
        }

        super.onCreate(savedInstanceState);
//        setContentView(R.layout.activity_main);
//        gprint = (TextView) findViewById(R.id.print);
//        StringBuilder sb = null;
//        sb = new StringBuilder();
//        sb.append(x[0].a);
//        gprint.setText(sb.toString());
    }
     class Complex{
        public double a;
        public double b;
        public Complex(double x,double y){
            a=x;
            b=y;
        }
         Complex plus(Complex m){
            Complex c= new Complex(0, 0);
            c.a=a+m.a;
            c.b=b+m.b;
            return c;
        }
         Complex multiply(Complex m)
         {
             Complex c= new Complex(0, 0);
             c.a=a*m.a-b*m.b;
             c.b=a*m.b+b*m.a;
             //  c.real=a.real*b.real - a.img*b.img;
             //  c.img=a.real*b.img + a.img*b.real;
             return c;
         }
         Complex minus(Complex m)
         {
             Complex c= new Complex(0, 0);
             c.a=a-m.a;
             c.b=b-m.b;
             return c;
         }
    }

    public Complex[] dft(Complex[] x) {
            int n = x.length;
            // exp(-2i*n*PI)=cos(-2*n*PI)+i*sin(-2*n*PI)=1
            if (n == 1)
                return x;
            Complex[] result = new Complex[n];
            for (int i = 0; i < n; i++) {
                result[i] = new Complex(0, 0);
                for (int k = 0; k < n; k++) {
                    //使用欧拉公式e^(-i*2pi*k/N) = cos(-2pi*k/N) + i*sin(-2pi*k/N)
                    double p = -2 * k * Math.PI* i / n;
                    Complex m = new Complex(Math.cos(p), Math.sin(p));
                    result[i]=result[i].plus(x[k].multiply(m));
                }
            }
            return result;
        }

        public Complex[] fft(Complex[] x) {
            int n = x.length;
            // 因为exp(-2i*n*PI)=1，n=1时递归原点
            if (n == 1) {
                return x;
            }
            // 如果信号数为奇数，使用dft计算
            if (n % 2 != 0) {
                return dft(x);
            }
            // 提取下标为偶数的原始信号值进行递归fft计算
            Complex[] even = new Complex[n / 2];
            for (int k = 0; k < n / 2; k++) {
                even[k] = x[2 * k];
            }
            Complex[] evenValue = fft(even);
            // 提取下标为奇数的原始信号值进行fft计算
            // 节约内存
            Complex[] odd = even;
            for (int k = 0; k < n / 2; k++) {
                odd[k] = x[2 * k + 1];
            }
            Complex[] oddValue = fft(odd);
            // 偶数+奇数
            Complex[] result = new Complex[n];
            for (int k = 0; k < n / 2; k++) {
                // 使用欧拉公式e^(-i*2pi*k/N) = cos(-2pi*k/N) + i*sin(-2pi*k/N)
                double p = -2 * k * Math.PI  / n;
                Complex m = new Complex(Math.cos(p), Math.sin(p));
                result[k] = evenValue[k].plus(m.multiply(oddValue[k]));
                // exp(-2*(k+n/2)*PI/n) 相当于 -exp(-2*k*PI/n)，其中exp(-n*PI)=-1(欧拉公式);
                result[k + n / 2] = evenValue[k].minus(m.multiply(oddValue[k]));
            }
            return result;
        }